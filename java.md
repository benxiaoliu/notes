JVM memory:
1. JVM 主要包括三块内存空间： 栈内存，堆内存，方法区内存
2. 堆内存和方法内存各有一个， 一个线程一个栈内存
3. 方法调用的时候，该方法所需要的内存空间在栈内存中分配，称为压栈。方法执行结束之后，该方法所属的内存空间释放，称为弹栈
4. 栈中主要存储的是方法体当中的局部变量
5. 方法的代码片段以及整个类的代码片段都被存储到方法区内存当中，在类加载的时候这些代码片段会载入
6. 在程序执行过程中使用new运算符创建的java对象，存储在堆内存当中。对象内部有实例变量。所以实例变量存储在堆内存当中
7. 变量分类：
    -局部变量（方法体中声明）
    -成员变量（方法体外声明）
      实例变量（前边修饰符没有static）
      静态变量（前边修饰符中有static）
8. 静态变量存储在方法区内存当中
9. 三块内存当中变化最频繁的是栈内存，最先有数据的是方法区内存。垃圾回收器主要针对的是堆内存
10. 垃圾回收器【自动垃圾回收机制，GC机制】
    -当堆内存当中的Java对象成为垃圾数据的时候，会被垃圾回收器回收
      没有更多的引用指向它的时候
      这个对象无法访问，因为访问对象只能通过引用的方式访问
      
Java 传产时传的是参数里面存的那个字面值

this 是一个引用，一个变量， this变量中保存了内存地址指向了自身，this存储在Java堆内存Java对象内部；代表当前对象

没有static的方法，变量被称为实例方法，变量，通过引用访问，先创建对象，具体的对象.xxx

带有static的方法是类的所有对象共有的，通过类名.xxx调用

带有static的方法当中不能直接访问实例变量和实例方法，因为实力变量和实例方法都需要对象的存在。而static的方法中是没有this的，也就是说当前对象是不存在的，自然也是无法访问当前对象的实例变量和实例方法。

object:
object 类是所有类的根父类 （默认继承）[子类可以执行父类的方法] [父类可以接收子类实例 Object o = new Student()]
若形参为一个类 但是不确定是什么类 就可用Object
public boolean equals (Object obj) 比较是不是指向同一个instance
public int hashCode()  取得Hash码
public String toSting()  返回的是对象内存地址 

hashCode()
我觉得hashcode可以看作是人的名字，人名相同的不一定是同一个人
默认情况下，hashCode方法是将对象的存储地址进行映射。
不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。

　　也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；

　　如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；

　　如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；

　　如果两个对象的hashcode值相等，则equals方法得到的结果未知。
  
  在重写equals方法的同时，必须重写hashCode方法. 
  只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。
  
  final： 最终
  可修饰 类（不能被继承），属性（不能被改变，必须在定义的时候就显式赋值）【常量，全大写】，方法（不能被重写）
  
  
