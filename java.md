JVM memory:
1. JVM 主要包括三块内存空间： 栈内存，堆内存，方法区内存
2. 堆内存和方法内存各有一个， 一个线程一个栈内存
3. 方法调用的时候，该方法所需要的内存空间在栈内存中分配，称为压栈。方法执行结束之后，该方法所属的内存空间释放，称为弹栈
4. 栈中主要存储的是方法体当中的局部变量
5. 方法的代码片段以及整个类的代码片段都被存储到方法区内存当中，在类加载的时候这些代码片段会载入
6. 在程序执行过程中使用new运算符创建的java对象，存储在堆内存当中。对象内部有实例变量。所以实例变量存储在堆内存当中
7. 变量分类：
    -局部变量（方法体中声明）
    -成员变量（方法体外声明）
      实例变量（前边修饰符没有static）
      静态变量（前边修饰符中有static）
8. 静态变量存储在方法区内存当中
9. 三块内存当中变化最频繁的是栈内存，最先有数据的是方法区内存。垃圾回收器主要针对的是堆内存
10. 垃圾回收器【自动垃圾回收机制，GC机制】
    -当堆内存当中的Java对象成为垃圾数据的时候，会被垃圾回收器回收
      没有更多的引用指向它的时候
      这个对象无法访问，因为访问对象只能通过引用的方式访问
      
Java 传产时传的是参数里面存的那个字面值

this 是一个引用，一个变量， this变量中保存了内存地址指向了自身，this存储在Java堆内存Java对象内部；代表当前对象

没有static的方法，变量被称为实例方法，变量，通过引用访问，先创建对象，具体的对象.xxx

带有static的方法是类的所有对象共有的，通过类名.xxx调用

带有static的方法当中不能直接访问实例变量和实例方法，因为实力变量和实例方法都需要对象的存在。而static的方法中是没有this的，也就是说当前对象是不存在的，自然也是无法访问当前对象的实例变量和实例方法。

object:
object 类是所有类的根父类 （默认继承）[子类可以执行父类的方法] [父类可以接收子类实例 Object o = new Student()]
若形参为一个类 但是不确定是什么类 就可用Object
public boolean equals (Object obj) 比较是不是指向同一个instance
public int hashCode()  取得Hash码
public String toSting()  返回的是对象内存地址 

hashCode()
我觉得hashcode可以看作是人的名字，人名相同的不一定是同一个人
默认情况下，hashCode方法是将对象的存储地址进行映射。
hashCode()方法和equals()方法都是Object类中的方法，不过hashCode()方法是一个native方法，它的返回值默认与System.identityHashCode(object)一致。这个值是对象头的一部分二进制位组成的数字，这个数字具有一定的标识对象的意义所在，但绝不等价于地址。
不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。
hashCode简单理解为对象的标识，一般用于hash算法中，这样就可以在查找数据的时候根据这个key快速的缩小数据范围。hashCode与equals似乎是天生一对，一个未来算法快速定位数据而存在，一个是为了对比真实值而存在。但是不能说hashCode是唯一的，不同对象的hashCode值可能会相同。

　　也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；

　　如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；

　　如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；

　　如果两个对象的hashcode值相等，则equals方法得到的结果未知。
  
  在重写equals方法的同时，必须重写hashCode方法. （在hashMap等集合的查找过程中是这样处理的，首先会对比根据hashCode值确定对应的桶，然后在桶里查找equals相同的对象，因此hashMap的查找速率比List要快。试想重写了equals()的两个对象相同，但没有覆写hashCode方法，很有可能会造成两个对象不再一个桶，这样map中的contains方法在查找的时候就找不到在其他桶的相同的对象了）
  
只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。
  
  final： 最终
  可修饰 类（不能被继承），属性（不能被改变，必须在定义的时候就显式赋值）【常量，全大写】，方法（不能被重写）
  
  Java 异常：
  用于处理非预期的情况，如文件没找到，网络错误，非法的参数
  解决方法： 终止程序的运行；程序员在编写程序时就考虑到错误的检测.错误消息的提示，以及错误的处理
  Error： JVM系统内部错误（StackOverFlowError, OutOfMemoryError）， 资源耗尽等严重情况
  Exception(IOException, RuntimeException)： 其他编程错误或偶然的外在因素导致的一般性问题，如空指针访问（指向空），试图读取不存在的文件，网络连接中断
  
  异常处理机制： 防止程序中断
  捕获 try{
  可能出现异常的代码段
  }catch(Excetion e){
  当不知道捕获的是什么类型的异常时，可以直接使用所有异常的父类Exception
  e.printStackTrace(); 打印异常的类型
  System.out.println(e.getMessage())  打印异常信息
  }catch{
  可多个捕获  （在捕获异常的代码块try中， 如果前面的代码有异常了，就不会执行后面的）
  finally{ 可选
  最终会执行的操作 
  }
  
  
  
  
  抛出
  throws
  throws抛出的异常，在调用方法去处理（try catch). main方法抛出的异常直接抛到虚拟机上去了，就在程序中不能处理
  
  子类不能抛出比父类还大的异常类型
  
  
  
  集合：用来存放对象的容器， 存放的是对象的引用
  集合可以存放不同类型，不限数量的数据类型
  Java集合可分为Set, List, Map 三大体系
  Set：无序，不可重复的集合
  HashSet 是Set接口的典型实现，大多数时候使用Set集合使用的都是这个实现类
  HashSet按Hash算法来存储集合中的元素
  HashSetb不能保证元素的排列顺序，不可重复，不是线程安全的，集合元素可以使用null
  当向HashSet集合中存入一个元素是，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据hashCode值决定该对象在HashSet中的存储位置 （存在set集合的哪个位置由这个值的hashcode决定； 如果两个元素的equals()方法返回true,但它们的hashCode() 返回值不相等，依然可以添加成功，但会把它们存储在不同的位置。
  
  
  
  
  
  List：有序，可重复的集合
  Map: 具有映射关系的集合
  
  
